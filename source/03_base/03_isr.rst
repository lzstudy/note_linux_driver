中断编程
==============

1 基础理论
------------

   1. 最初内核使用底半步BH, 后来使用软中断和tasklet代替了上述概念
   2. 内核一共定义了10个软中断, tasklet属于这其中

=================== =================== =========================================
位置                 函数                特性
中断上半部           request_irq         直接工作在中断上半部, 要求工作时间段、少
中断底半部           tasklet             需要做大量工作, 且不能睡眠, 或重新调度
进程上下文           workqueue           需要推后的工作需要睡眠或重新调度
=================== =================== =========================================

2 相关接口
------------

2.1 中断申请接口
********************
=============== ==================================
request_irq();   中断处理函数, 处理函数属于上半步
=============== ==================================

2.2 tasklet接口
********************
===================== =====================
DECLARE_TASKLET();    静态初始化
tasklet_init();       动态初始化
tasklet_schedule();   任务调度开启
===================== =====================

2.3 工作队列
***************
===================== =========================
DECLARE_WORK();       一次性完成创建和初始化任务
schedule_work();      调度任务
===================== =========================

3 设备树
--------------

  设备树中的中断cells一般为3个, ``#interrupt-cells = <3>``, 分别表示中断类型、中断号、中断标志, 
  比如 ``interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>``。

  GPIO中断cell一般为2个, 并且引用父中断, ``interrupts = <18 IRQ_TYPE_EDGE_BOTH>``

.. code-block:: c

    key-gpio = <&gpio1 18 GPIO_ACTIVE_LOW>;
    interrupt-parent = <&gpio1>;
    interrupts = <18 IRQ_TYPE_EDGE_BOTH>;

================================== =====================
irq_of_parse_and_map(np, index);   通过读取节点获取中断号
gpio_to_irq(gpio);                 通过gpio号获取中断号
================================== =====================

4 中断调试
---------------

.. code-block:: c

    cat /proc/interrupts
